#! /usr/bin/env python3


"""
TODO - module docstring
"""


import argparse
import os
import math
import time
import boto3


context = {}


def load_context():
    arguments = parse_arguments()

    context = {
        "arguments": arguments,
        "environment": load_environment(),
        "directory": directory_information(arguments.directory)
    }

    return context


def parse_arguments():
    """ Parse command line arguments and return a Namespace object. """
    parser = argparse.ArgumentParser(
        description="The ec2-backup tool performs a backup of the given "     \
        "directory into Amazon Elastic Block Storage (EBS).  This is "        \
        "achieved by creating a volume of the appropriate size, attaching "   \
        "it to an EC2 instance and finally copying the files from the given " \
        "directory onto this volume."
    )

    parser.add_argument(metavar="dir", dest="directory")

    parser.add_argument(
        "-l", metavar="filter", dest="local_filter", help="Pass data "      \
        "through the given filter command on the localhost before copying " \
        "the data to the remote system.")

    parser.add_argument(
        "-r", metavar="filter", dest="remote_filter", help="Pass data " \
        "through the given filter command on the remote host before writing " \
        "the data to the volume.")

    parser.add_argument(
        "-v", metavar="volume-id", dest="volume_id", help="Use the given " \
        "volume instead of creating a new one.")

    arguments = parser.parse_args()

    return arguments


def load_environment():
    """ Parse environment variables and return a dictionary object. """
    environment = {
        "VERBOSE": os.getenv("EC2_BACKUP_VERBOSE", False),
        "AWS_FLAGS": os.getenv("EC2_BACKUP_FLAGS_AWS", ""),
        "SSH_FLAGS": os.getenv("EC2_BACKUP_FLAGS_SSH", "")
    }

    return environment


def directory_information(target: str):
    """ Returns the size of a target to the nearst gigabyte. """
    information = {
        "path": os.path.abspath(target),
	"size": {
            "GB": 0,
            "B": 0
        }
    }

    for relative_path, _, filenames in os.walk(target):
        for filename in filenames:
            filepath = os.path.join(relative_path, filename)
            information["size"]["B"] += os.path.getsize(filepath)

    # Nearest GB
    information["size"]["GB"] = math.ceil(information["size"]["B"] / (2 ** 30))

    return information


def verbose(message: str):
    """ Prints verbose trace messages to STDOUT. """
    if context["environment"]["VERBOSE"]:
        print("ec2-backup: ".format(message))

    return


class Volume:
    @staticmethod
    def query(identifier: str):
        print("".format())
        ec2_connection = boto3.resource("ec2")
        return ec2_connection.volume(identifier)


class Instance:
    def __init__(self):
        """ Initialize instance default launche configuration. """
        self.image_id = "ami-569ed93c"
        self.instance_type = "t1.micro"
        self.wait_delay = 5.000

        self.identifier = None
	
        verbose("Initialized instance launch configuration:")
        verbose("AMI = {}".format(self.image_id))
        verbose("TYPE = {}".format(self.instance_type))

        return


    def create(self):
        """ Create an AWS EC2 instance with an attached EBS volume. """
        verbose("Opening connection with AWS API...")
        ec2_connection = boto3.resource("ec2")

        verbose("Creating EC2 instance with EBS...")
        response = ec2_connection.create_instances(
            BlockDeviceMappings=[
        {
            'DeviceName': 'sdb',
            'Ebs': {
                'Encrypted': False,
                'DeleteOnTermination': False,
                'VolumeSize': 2 * context["directory"]["size"]["GB"],
                'VolumeType': 'standard'
            },
        },
    ],
            ImageId=self.image_id,
            InstanceType=self.instance_type,
            #Region=None,
            #Placement={
            #    "AvailabilityZone": None
            #},
            MinCount=1,
            MaxCount=1,
            InstanceInitiatedShutdownBehavior="terminate"
        )

        instance = response[0]
        self.identifier = instance.id

        # Wait for the instance to enter a running state
        verbose("Waiting for EC2 instance to enter running state...")
        while instance.state.get("Name") != "running":
            time.sleep(self.wait_delay)
            verbose("Checking instance state...")
            instance.reload()

        return


    def terminate(self):
        """ Terminate the provided AWS EC2 instance. """
        if self.identifier is None:
            return

        verbose("Opening a connection to the AWS API...")
        ec2_connection = boto3.resource("ec2")

        verbose("Filtering instance by identifier...")
        results = ec2_connection.instances.filter(
            InstanceIds=[
                self.identifier
            ]
        )

        verbose("Terminating instance...")
        results.terminate()

        return


def main():
    """ Main run-time function. """
    global context
    context = load_context()

    verbose("Evaluated runtime context: {}".format(context))

    return


if __name__ == "__main__":
    main()
